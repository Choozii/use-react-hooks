{"/hooks/_template":{"title":"훅 이름","data":{"introduce#Introduce":"훅에 대한 설명\n(모든 설명은 '-다.'로 끝맺기)\n// 훅 인터페이스\ninterface UseSomethingHookProps {}\ninterface UseSomethingHookReturns {}\nconst useSomethingHook = (props: UseSomethingHookProps): UseSomethingHookReturns","props#Props":"","소제목선택#소제목(선택)":"","returns#Returns":"","소제목선택-1#소제목(선택)":"","examples#Examples":"// 훅 사용 예시\n// copy 옵션 필수\n// 기본적인 컴포넌트이름으로 filename=\"TestComponent.tsx\", 그 외로는 SomethingProvider.tsx 등\n// https://nextra.site/docs/guide/syntax-highlighting 하이라이팅 참고"}},"/hooks/useAsyncTasks":{"title":"useAsyncTasks","data":{"introduce#Introduce":"비동기 작업 리스트와 옵션을 받아 로딩 상태, 데이터, 오류 등을 관리하며, 컴포넌트 언마운트 시 상태 업데이트를 방지합니다.\ninterface UseAsyncTasksProps<R> {\n  tasks: Task<R>[];\n  options?: Options<R>;\n}\ninterface UseAsyncTasksReturns<R> {\n  isLoading: boolean;\n  data: R | null;\n  error: Error | null;\n  isError: boolean;\n  reset: () => void;\n}\nconst useAsyncTasks = <R>(tasks: Task<R>[], options: Options<R>): UseAsyncTasksReturns<R> => { ... }","props#Props":"tasks : 실행할 비동기 작업들의 배열입니다. 비동기 함수 외에도 일반 함수, 원시 데이터 등을 전달할 수 있습니다.","returns#Returns":"isLoading : 현재 비동기 작업이 진행 중인지 여부를 나타내는 불리언 값입니다.\ndata : 성공적으로 완료된 작업의 결과를 담고 있는 데이터입니다.\nerror : 작업 중 발생한 오류 정보를 포함합니다.\nisError : 오류가 발생했는지 여부를 나타내는 불리언 값입니다.\nreset : 이전 상태를 초기화하여 초기 상태로 되돌리는 함수입니다.","examples#Examples":"const fetchUsers = async () => {\n  const response = await fetch(`https://jsonplaceholder.typicode.com/users`);\n  if (!response.ok) throw new Error('사용자 목록을 가져오지 못했습니다.');\n  return response.json();\n};\nconst TestComponent = () => {\n  const { isLoading, data, error, isError, reset } = useAsyncTasks<\n    { id: string; name: string }[]\n  >([fetchUsers], {\n    onSuccess: () => console.log('사용자 목록을 성공적으로 가져왔습니다!'),\n    onError: (err) => console.error('오류:', err),\n  });\n  return (\n    <div>\n      <button onClick={reset}>재로드</button>\n      {isLoading && <p>로딩 중...</p>}\n      {isError && <p>오류: {error?.message}</p>}\n      {data && (\n        <ul>\n          {data.map((user) => (\n            <li key={user.id}>{user.name}</li>\n          ))}\n        </ul>\n      )}\n    </div>\n  );\n};"}},"/hooks/useClipboard":{"title":"useClipboard","data":{"introduce#Introduce":"클립보드에 텍스트나 이미지를 복사할 수 있도록 도와주는 훅입니다.\n// 훅 인터페이스\nexport interface UseClipboardProps {\n  resetTime?: number;\n}\nexport interface UseClipboardReturns {\n  copied: boolean;\n  copyText: (text: string) => void;\n  copyImg: (path: string) => void;\n}\nconst useClipboard = (props: UseClipboardProps): UseClipboardReturns\n이미지는 URL을 입력해 복사할 수 있습니다.\n클립보드 API가\n지원되지 않는 환경에선 에러가 발생합니다.","props#Props":"resetTime: 복사 성공 후, 복사 상태에 대한 플래그(copied)가 리셋되는 시간(ms)\ndefault: 5000","returns#Returns":"copied: 클립보드 복사가 성공했는지를 나타내는 플래그\ncopyText: 텍스트를 클립보드에 복사하는 비동기 함수\ncopyImg: 이미지를 클립보드에 복사하는 함수","examples#Examples":"import { useClipboard } from '@frontend-opensource/use-react-hooks';\nconst TestComponent = () => {\n  const { copied, copyText, copyImg } = useClipboard();\n  return (\n    <div>\n      <button onClick={() => copyText('Hello World')}>Copy Text</button>\n      <button onClick={() => copyImg('https://example.com/image.png')}>\n        Copy Image\n      </button>\n      <p> {copied ? 'Copied!' : ''}</p>\n    </div>\n  );\n};"}},"/hooks/useConfirm":{"title":"useConfirm","data":{"introduce#Introduce":"컨펌 로직을 담고 있는 훅입니다.\n컨펌 다이얼로그를 구현할 때 유용하게 사용할 수 있습니다.\ninterface UseConfirmReturns {\n  message?: string;\n  isOpen: boolean;\n  confirm: (message: string) => Promise<boolean>;\n  onConfirm: () => void;\n  onCancel: () => void;\n}\nconst useConfirm = (): UseConfirmReturns","returns#Returns":"message: 컨펌 메시지. confirm() 함수에 전달된 값을 그대로 반환.\nisOpen: 컨펌 다이얼로그 open/close 상태를 제어할 수 있는 값. confirm() 함수 실행 단계에서 message를 체크하여 값을 반환.\nconfirm: 컨펌 로직을 실행하는 비동기 함수. 컨펌 다이얼로그를 열고 사용자의 컨펌 여부를 반환.\nonConfirm: 컨펌을 실행하는 함수.\nonCancel: 취소를 실행하는 함수.","examples#Examples":"useConfirm()을 사용하기 전에 먼저 ConfirmProvider를 선언해야 합니다.\nimport { ConfirmProvider } from '@frontend-opensource/use-react-hooks';\nfunction App() {\n  return (\n    <ConfirmProvider>\n      <TestComponent />\n    </ConfirmProvider>\n  );\n}\nimport { useConfirm } from '@frontend-opensource/use-react-hooks';\nconst TestComponent = () => {\n  const { message, isOpen, confirm, onConfirm, onCancel } = useConfirm();\n  const handleRemove = async () => {\n    if (await confirm('정말 삭제하시겠습니까?')) {\n      // 컨펌 로직\n    } else {\n      // 취소 로직\n    }\n  };\n  return (\n    <>\n      <button onClick={handleRemove}>삭제하기</button>\n      <Dialog open={isOpen}>\n        <p>{message}</p>\n        <button onClick={onConfirm}>확인</button>\n        <button onClick={onCancel}>취소</button>\n      </Dialog>\n    </>\n  );\n};"}},"/hooks/useDebounce":{"title":"useDebounce","data":{"introduce#Introduce":"일정 시간(delay) 동안 호출이 연속적으로 발생하면, 마지막 호출이 끝난 후에만 콜백 함수가 실행되도록 지연시키는 훅입니다.\nconst useDebounce = <T extends unknown[]>(\n  callback: (...args: T) => void,\n  delay: number\n): (...args: T) => void\n입력 필드나 스크롤 이벤트와 같은 상황에서 불필요한 렌더링이나 API 호출을 줄여 성능을 최적화할 수 있습니다.","props#Props":"callback : 사용자가 연속적인 동작을 멈춘 후 실행되는 콜백함수\ndelay : 지연 시간(밀리초)","returns#Returns":"(...args: T) => void : 디바운스된 콜백 함수","examples#Examples":"const TestComponent = () => {\n  const [searchText, setSearchText] = useState('');\n  const [debouncedText, setDebouncedText] = useState(searchText);\n  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {\n    const newValue = e.target.value;\n    setSearchText(newValue);\n    debounceSearchText(newValue);\n  };\n  const debounceSearchText = useDebounce((text: string) => {\n    setDebouncedText(text);\n  }, 200);\n  const filteredUsers = users.filter((u) =>\n    u.name.toLowerCase().includes(debouncedText.toLowerCase())\n  );\n  return (\n    <div>\n      <input type=\"text\" value={searchText} onChange={handleChange} />\n      <ul>\n        {filteredUsers.map((u) => (\n          <li key={u.id}>{u.name}</li>\n        ))}\n      </ul>\n    </div>\n  );\n};"}},"/hooks/useDeepCompareEffect":{"title":"useDeepCompareEffect","data":{"introduce#Introduce":"의존성 배열의 깊은 비교를 통해 변화를 감지하고 콜백을 실행시키는 훅입니다.\nconst useDeepCompareEffect = (callback: () => void, dependencies: unknown[]) => void","props#Props":"callback : 의존성 배열의 변화가 감지되었을 때 실행할 콜백 함수\ndependencies : 의존성 배열","examples#Examples":"function App() {\n  const [, setCount] = useState(0);\n  const effectCountRef = useRef(0);\n  const deepCompareCountRef = useRef(0);\n  useEffect(() => {\n    effectCountRef.current += 1;\n    // 빈 객체는 매번 새로운 참조를 갖기 때문에 effectCount는 계속 증가\n  }, [{}]);\n  useDeepCompareEffect(() => {\n    deepCompareCountRef.current += 1;\n    // 빈 객체를 같은 값으로 판단해 deepCompareCountRef는 한 번(첫 시도)만 증가\n  }, [{}]);\n  return (\n    <div>\n      <p>effectCount: {effectCountRef.current}</p>\n      <p>deepCompareCount: {deepCompareCountRef.current}</p>\n      <p>\n        <button type=\"button\" onClick={() => setCount((c) => c + 1)}>\n          리렌더링 발생\n        </button>\n      </p>\n    </div>\n  );\n}"}},"/hooks/useDelayFlag":{"title":"useDelayFlag","data":{"introduce#Introduce":"플래그를 원하는 시간만큼 지연시킨 후에 업데이트하는 훅입니다.\ntype UseDelayFlagProps<T extends number> = {\n  flag: boolean;\n  delayTime?: PositiveInteger<T>;\n};\ntype UseDelayFlagReturns = boolean;\nconst useSomethingHook = (props: UseDelayFlagProps): UseDelayFlagReturns\n데이터 페칭 시, 페칭(또는 로딩) 플래그를 지연시킨 시간동안 유지하여 로딩 UI의 깜빡임 현상 제거, 중복 호출 방지 등의 용도로 사용할 수 있습니다.\n지연시킨 시간보다 플래그의 업데이트가 더 늦을 경우 지연 시간을 무시하고 플래그의 실제 업데이트 시점을 반환합니다.","props#Props":"flag : 지연시킬 플래그\ndelayTime : 지연시킬 시간(ms)\n양의 정수만 가능\n기본값: 1000","returns#Returns":"delayTime 만큼 지연시킨 후에 업데이트된 flag 반환","examples#Examples":"import { useEffect, useState } from 'react';\nimport { useDelayFlag } from '@frontend-opensource/use-react-hooks';\nfunction App() {\n  const [flag, setFlag] = useState(true);\n  const delayFlag = useDelayFlag({ flag, delayTime: 3000 });\n  // 1초 뒤에 flag를 업데이트하는 함수\n  const updateFlagAsync = async () => {\n    await new Promise((resolve) => setTimeout(resolve, 1000));\n    setFlag(false);\n  };\n  useEffect(() => {\n    updateFlagAsync();\n  }, []);\n  return (\n    <div>\n      {/* 1초 뒤에 flag 업데이트됨 */}\n      {flag ? <p>Loading...</p> : <p>Loaded</p>}\n      {/* 3초 뒤에 delayFlag 업데이트됨 */}\n      {delayFlag ? <p>Delayed Loading...</p> : <p>Delayed Loaded</p>}\n    </div>\n  );\n}"}},"/hooks/useEventListener":{"title":"useEventListener","data":{"introduce#Introduce":"특정 객체에 이벤트 리스너를 손쉽게 추가할 수 있는 훅입니다.\nexport type EventMap = {\n  window: WindowEventMap;\n  document: DocumentEventMap;\n  htmlElement: HTMLElementEventMap;\n  svgElement: SVGElementEventMap;\n};\nexport type EventElement = {\n  window: Window;\n  document: Document;\n  htmlElement: RefObject<HTMLElement> | HTMLElement;\n  svgElement: RefObject<SVGElement> | SVGElement;\n};\nconst useEventListener = <\n  K extends keyof EventMap,\n  E extends keyof EventMap[K] & string,\n>(\n  eventName: E,\n  handler: (event: EventMap[K][E]) => void,\n  element?: EventElement[K] | null,\n  options?: AddEventListenerOptions\n): void\n현재 이벤트 리스너를 추가할 수 있는 객체는 window, document, htmlElement, svgElement 4가지입니다.","props#Props":"eventName: 추가할 이벤트의 이름\nhandler: 이벤트 발생 시 실행되는 핸들러 함수\nelement: 이벤트를 추가할 대상 Element\ndefault: window\noptions: 이벤트 리스너 기본 옵션","examples#Examples":"import { useEventListener } from '@frontend-opensource/use-react-hooks';\nconst TestComponent = () => {\n  const buttonRef = useRef<HTMLButtonElement>(null);\n  const handleClick = () => {\n    console.log('Button clicked!');\n  };\n  useEventListener('click', handleClick, buttonRef);\n  return (\n    <div>\n      <button ref={buttonRef}>Click</button>\n    </div>\n  );\n};"}},"/hooks/useDetectDevice":{"title":"useDetectDevice","data":{"introduce#Introduce":"현재 디바이스의 유형(moblie, desktop), OS 및 Browser를 감지합니다.\nuserAgent의 업데이트로 인하여 올바르게 작동하지 않을 수 있습니다. 유의해서\n사용해주세요.\ninterface UseDeviceDetectReturns {\n  isMobile: boolean;\n  isDesktop: boolean;\n  os: string;\n  browser: string;\n}\nconst useDetectDevice = (): UseDeviceDetectReturns","returns#Returns":"isMobile : 사용 중인 디바이스의 Mobile 여부를 나타냅니다.\nisDesktop : 사용 중인 디바이스의 Desktop 여부를 나타냅니다.\nos : 사용 중인 디바이스의 OS 이름(문자열)을 나타냅니다.\ncf) Windows, macOS, Linux, Android, iOS\nbrowser : 사용 중인 브라우저의 이름(문자열)을 나타냅니다.\ncf) Chrome, Safari, Whale, Edge, Firefox","examples#Examples":"const TestComponent = () => {\n  const { isMobile, os, browser } = useDeviceDetect();\n  return (\n    <div>\n      <div>\n        {isMobile && (\n          <>\n            <div>모바일 환경에 최적화된 콘텐츠</div>\n            <div>...</div>\n          </>\n        )}\n    </div>\n  );\n};"}},"/hooks/useGeolocation":{"title":"useGeolocation","data":{"":"이 훅은 브라우저의 Geolocation API를 사용하여 사용자의 위치 정보를 가져옵니다.\n지원되지 않는 브라우저에서는 정확한 위치 정보를 제공하지 않을 수 있습니다.","introduce#Introduce":"useGeolocation 훅은 사용자의 위치 정보를 가져와 상태를 관리하는 기능을 제공합니다.\n이 훅은 위치 정보의 위도, 경도, 고도 등 다양한 위치 데이터를 반환하며, 위치 정보 수집 중 발생한 오류도 함께 반환합니다.\nexport interface UseGeolocationReturnType {\n  loading: boolean;\n  error: GeolocationPositionError | null;\n  timestamp?: EpochTimeStamp;\n  latitude?: number;\n  longitude?: number;\n  altitude?: number;\n  accuracy?: number;\n  altitudeAccuracy?: number;\n  heading?: number;\n  speed?: number;\n}\nconst useGeolocation = (\n  options?: PositionOptions\n): UseGeolocationReturnType;","props#Props":"options : 위치 정보를 가져올 때 사용할 옵션\nenableHighAccuracy : 위치 정보를 높은 정확도로 수집할지 여부 (기본값: false)\ntimeout : 위치 정보를 가져오기 위해 대기할 최대 시간 (밀리초 단위)\nmaximumAge : 위치 정보를 캐싱할 최대 시간 (밀리초 단위)","returns#Returns":"loading : 위치 정보를 가져오는 중인지 여부\nerror : 발생한 오류\ntimestamp : 위치 정보의 타임스탬프\nlatitude : 현재 위치의 위도\nlongitude : 현재 위치의 경도\naltitude : 현재 위치의 고도\naccuracy : 위치 정보의 정확도\naltitudeAccuracy : 고도 정보의 정확도\nheading : 이동 방향\nspeed : 현재 속도","examples#Examples":"import useGeolocation from './useGeolocation';\nconst GeolocationComponent = () => {\n  const {\n    latitude,\n    longitude,\n    altitude,\n    accuracy,\n    altitudeAccuracy,\n    heading,\n    speed,\n    timestamp,\n    error,\n    loading,\n  } = useGeolocation({ enableHighAccuracy: true });\n  if (loading) {\n    return <p>위치 정보를 가져오는 중입니다...</p>;\n  }\n  if (error) {\n    return <p>오류 발생: {error.message}</p>;\n  }\n  return (\n    <div>\n      <h2>위치 정보</h2>\n      <p>위도: {latitude}</p>\n      <p>경도: {longitude}</p>\n      <p>고도: {altitude}</p>\n      <p>정확도: {accuracy} meters</p>\n      <p>고도 정확도: {altitudeAccuracy} meters</p>\n      <p>방향: {heading} degrees</p>\n      <p>속도: {speed} m/s</p>\n      <p>타임스탬프: {new Date(timestamp || 0).toLocaleTimeString()}</p>\n    </div>\n  );\n};"}},"/hooks/useHover":{"title":"useHover","data":{"introduce#Introduce":"ref로 지정한 요소에 마우스가 올라와 있는지 감지하는 훅입니다.\nexport interface UseHoverReturns<T> {\n  isHovered: boolean;\n  callbackRef: (node: T) => void;\n}\nconst useHover = <T extends HTMLElement>(): UseHoverReturns<T>\ncallbackRef를 사용하여 ref 객체를 관리하고 마우스 이벤트 리스너를 추가합니다.","returns#Returns":"isHovered: 마우스가 요소 위에 있는지 여부를 나타내는 불리언 값\ncallbackRef: 대상 요소의 ref 속성에 할당하여 마우스 이벤트 리스너를 추가하는 함수","examples#Examples":"cconst TestComponent = () => {\n  const { isHovered, callbackRef } = useHover();\n  return (\n    <div\n      ref={callbackRef}\n      style={{ backgroundColor: isHovered ? '#f00' : '#fff' }}\n    >\n      {isHovered ? 'Hovered!' : 'Not Hovered'}\n    </div>\n  );\n};"}},"/hooks/useIntersectionObserver":{"title":"useIntersectionObserver","data":{"introduce#Introduce":"IntersectionObserver API를 활용하여 요소의 가시성을 감지합니다.\ninterface UseIntersectionObserverProps {\n  root?: Element | null;\n  rootMargin?: string;\n  threshold?: number | number[];\n  visibleOnce?: boolean;\n  initialView?: boolean;\n  onChange?: (isView: boolean, entry: IntersectionObserverEntry) => void;\n  onEnter?: () => void;\n  onLeave?: () => void;\n}\ninterface UseIntersectionObserverReturns {\n  intersectionRef: Dispatch<SetStateAction<Element | null>>;\n  isView: boolean;\n  entry?: IntersectionObserverEntry | null;\n}\nconst useIntersectionObserver = (props: UseIntersectionObserverProps): UseIntersectionObserverReturns","props#Props":"","intersectionobserver-api-기본-옵션#IntersectionObserver API 기본 옵션":"root : 뷰포트 대신 사용할 요소 객체 지정. 기본적으로 브라우저의 뷰포트가 사용됨(null)\nrootMargin : Root의 범위를 확장하거나 축소시킴\nthreshold : observer가 실행되기 위한 최소한의 타켓의 가시성 비율","부가옵션#부가옵션":"initialView : 초기 감지값 설정 옵션\nvisibleOnce : 처음 한번만 감지하는 옵션","callback-함수#callback 함수":"onChange : 타겟 Element의 가시성 상태가 변경될 때 호출할 콜백 함수\nonEnter : 타겟 Element가 화면에 나타날 때 호출할 콜백 함수\nonLeave : 타겟 Element가 화면에서 사라질 때 호출할 콜백 함수","returns#Returns":"intersectionRef : 훅에서 사용할 요소의 상태를 설정하는 데 사용되는 디스패치 함수. 감지하고자 하는 Element에 설정\nisView : Element가 현재 뷰포트 내에 보이는지 여부를 나타내는 상태 값\nentry : Intersection Observer API를 사용하여 Element의 교차 상태 관련 정보를 나타내는 객체\n아래 공식문서에서 entry에 대한 더 자세한 사항을 확인할 수 있습니다.\nhttps://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry","examples#Examples":"","lazy-loading#Lazy Loading":"타겟 Element가 뷰포트에 보일때마다 리스트에 3개의 item이 비동기적으로 추가되는 예시\nconst TestComponent = () => {\n  const nextItemRef = useRef(1);\n  const [items, setItems] = useState<number[]>([]);\n  const [loading, setLoading] = useState(false);\n  const fetchItems = async () => {\n    return new Promise<number[]>((resolve) => {\n      setTimeout(() => {\n        const newItems = [\n          nextItemRef.current,\n          nextItemRef.current + 1,\n          nextItemRef.current + 2,\n        ];\n        nextItemRef.current += 3;\n        resolve(newItems);\n      }, 1000);\n    });\n  };\n  const handleIntersectionChange = async (isView: boolean) => {\n    if (isView && !loading) {\n      setLoading(true);\n      try {\n        const newItems = await fetchItems();\n        setItems((prevItems) => [...prevItems, ...newItems]);\n        setLoading(false);\n      } catch (error) {\n        console.error(error);\n        setLoading(false);\n      }\n    }\n  };\n  const { intersectionRef } = useIntersectionObserver({\n    threshold: 0.5,\n    onChange: handleIntersectionChange,\n  });\n  return (\n    <div>\n      <div style={{ height: '1000px' }}></div>\n      <div\n        style={{\n          padding: '30px',\n          backgroundColor: 'lightblue',\n        }}>\n        {items.map((item, index) => (\n          <div\n            key={index}\n            style={{\n              margin: '10px',\n              height: '20px',\n              backgroundColor: 'lightyellow',\n              padding: '10px',\n            }}>\n            Item {item}\n          </div>\n        ))}\n        {loading && <p>아이템 로드 중...</p>}\n      </div>\n      <div ref={intersectionRef}> </div>\n    </div>\n  );\n};\nexport default TestComponent;"}},"/hooks/useInterval":{"title":"useInterval","data":{"introduce#Introduce":"지정된 시간 간격만큼 반복적으로 콜백 함수를 호출하는 훅입니다.\nconst useInterval = (callback: () => void, ms: number): () => void\n지정된 시간 간격으로 콜백 함수를 호출하는 타이머를 설정합니다.\nms 값이 변경될 때마다 interval이 재설정되며, 컴포넌트가 언마운트될 때 자동으로 타이머가 정리됩니다.\n반환된 clear 함수를 호출하여 수동으로 타이머를 중지할 수도 있습니다.","props#Props":"callback : 지정된 간격마다 호출될 콜백 함수\nms : 콜백 함수가 호출되는 시간 간격(밀리초)","returns#Returns":"interval 중지 함수","examples#Examples":"function TestComponent() {\n  const [count, setCount] = useState(0);\n  const [delay, setDelay] = useState(1000);\n  const clear = useInterval(() => {\n    setCount(count + 1);\n  }, delay);\n  const handleStop = () => {\n    clear();\n  };\n  const handleDelay = ({ target }) => {\n    setDelay(target.value);\n  };\n  return (\n    <div>\n      <input type=\"number\" value={delay} onChange={handleDelay} />\n      <button onClick={handleStop}>stop</button>\n      <div>{count}</div>\n    </div>\n  );\n}"}},"/hooks/useKeyCombination":{"title":"useKeyCombination","data":{"introduce#Introduce":"지정된 키 조합을 눌렀을 때 콜백 함수를 호출하는 훅입니다.\n지정된 키들을 모두 눌렀을 때 콜백 함수를 호출하며, 필요에 따라 기본 동작을 막을 수도 있습니다.\n예를 들어, Ctrl + K 키 조합을 감지하여 특정 작업을 실행하고자 할 때 사용할 수 있습니다.\ninterface UseKeyCombinationProps {\n  shortcutKeys: string[];\n  callback: () => void;\n  isPrevent?: boolean;\n}\nconst useKeyCombination = ({\n  shortcutKeys,\n  callback,\n  isPrevent = false,\n}: UseKeyCombinationProps): void","props#Props":"shortcutKeys : 키 조합을 나타내는 키 코드의 배열\ncallback : 키 조합이 감지되었을 때 실행할 콜백 함수\nisPrevent : true로 설정하면 키 조합이 눌렸을 때 기본 동작 방지 (기본값: false)","examples#Examples":"import { useCallback, useRef, useState } from 'react';\nimport useKeyCombination from './hooks/useKeyCombination';\nfunction TestComponent() {\n  const [bold, setBold] = useState(false);\n  const [isSave, setIsSave] = useState(false);\n  const input = useRef<HTMLInputElement>(null);\n  const keyActions = {\n    toggleBold: {\n      shortcutKeys: ['ControlLeft', 'KeyB'],\n      callback: useCallback(() => {\n        setBold((state) => !state);\n      }, [setBold]),\n    },\n    save: {\n      shortcutKeys: ['MetaLeft', 'KeyS'],\n      callback: useCallback(() => setIsSave((state) => !state), [setIsSave]),\n      isPrevent: true,\n    },\n    search: {\n      shortcutKeys: ['MetaLeft', 'KeyK'],\n      callback: useCallback(() => input.current?.focus(), []),\n    },\n  };\n  useKeyCombination(keyActions.toggleBold);\n  useKeyCombination(keyActions.save);\n  useKeyCombination(keyActions.search);\n  return (\n    <div>\n      <input type=\"text\" ref={input} placeholder=\"Press command + K\" />\n      <div>USE-REACT-HOOKS</div>\n      <ul>\n        <li style={{ fontWeight: bold ? 'bold' : 'normal' }}>\n          command + B : Bold\n        </li>\n        <li>command + S: {isSave ? 'SAVE!' : 'Not saved yet'}</li>\n      </ul>\n    </div>\n  );\n}"}},"/hooks/useKeyDown":{"title":"useKeyDown","data":{"introduce#Introduce":"사용자가 특정 키를 눌렀을 때 콜백 함수를 호출하는 훅입니다.\n주어진 키 입력을 감지하여 사용자가 지정한 콜백 함수를 실행합니다.\n모달, 드롭다운 메뉴 등에서 Escape 키를 감지하여 닫기 기능을 구현할 때 유용합니다.\nexport interface UseKeyDownProps {\n  key: string;\n  onKeyPress: () => void;\n}\nconst useKeyDown = ({ key, onKeyPress }: UseKeyDownProps): void","props#Props":"key : 감지할 키 값. 예를 들어, 'Escape', 'Enter' 등의 키를 사용할 수 있습니다.\nonKeyPress : 지정된 키가 눌렸을 때 호출될 콜백 함수.","examples#Examples":"function TestComponent() {\n  const [isKeyPressed, setIsKeyPressed] = useState(false);\n  useKeyDown({ key: 'Enter', onKeyPress: () => setIsKeyPressed(true) });\n  return (\n    <div>\n      <h1>{isKeyPressed ? 'Enter Key Pressed!' : 'Press Enter Key'}</h1>\n    </div>\n  );\n}\nexport default TestComponent;"}},"/hooks/useLocalStorage":{"title":"useLocalStorage","data":{"introduce#Introduce":"로컬 스토리지와 동기화된 상태를 관리하는 훅입니다.브라우저의 로컬 스토리지 API를 간편하게 사용할 수 있도록 도와주며,\n타입 일관성을 유지하기 위해 잘못된 값이 저장되지 않도록 차단합니다.\ninterface UseLocalStorageHookProps<T> {\n  key: string;\n  initialValue: T;\n}\ninterface UseLocalStorageHookReturns<T> extends Readonly<[T, (value: ValueResolver<T>) => void]> {}\nconst useLocalStorage = <T>(\n  key: string,\n  initialValue: T\n): UseLocalStorageHookReturns<T>\n값의 타입이 일치하지 않을 경우 초기값으로 재설정합니다. 또한, 브라우저\n환경에서만 동작하므로 서버 환경에서는 사용할 수 없습니다.","props#Props":"key : 로컬 스토리지에 저장할 값의 키를 지정합니다.\ninitialValue : 저장할 초기 값을 설정합니다. 만약 로컬 스토리지에 기존 값이 존재하지 않거나 타입이 다른 경우, 해당 초기값이 사용됩니다.","returns#Returns":"[storedValue, setValue] : 첫 번째 요소는 저장된 값이며, 두 번째 요소는 해당 값을 업데이트하는 함수입니다.","examples#Examples":"const TestComponent = () => {\n  const [value, setValue] = useLocalStorage<number>('count', 0);\n  const handleIncrement = () => setValue((prev) => prev + 1);\n  const handleReset = () => setValue(0);\n  return (\n    <div>\n      <p>Stored Value: {value}</p>\n      <button onClick={handleIncrement}>Increment</button>\n      <button onClick={handleReset}>Reset</button>\n    </div>\n  );\n};"}},"/hooks/useLongPress":{"title":"useLongPress","data":{"introduce#Introduce":"사용자가 요소를 길게 눌렀을 때 콜백 함수를 호출합니다.\nexport type Fn = () => void;\nexport interface UseLongPressReturns {\n  onMouseDown: Fn;\n  onMouseUp: Fn;\n  onMouseLeave: Fn;\n  onTouchStart: Fn;\n  onTouchEnd: Fn;\n}\nconst useLongPress = (callback: Fn, delay: number = 500): UseLongPressReturns\n사용자가 요소를 지정한 시간 이상 누르고 있을 때 콜백 함수가 호출되며, 마우스와 터치 이벤트를 모두 지원합니다.","props#Props":"callback : 사용자가 요소를 길게 눌렀을 때 호출될 콜백 함수\ndelay : 사용자가 요소를 길게 눌러야 하는 시간(밀리초, 기본값 500ms)","returns#Returns":"UseLongPressReturns : 요소에 연결될 이벤트 핸들러 객체. 다음 다섯 가지 이벤트가 반환됩니다.\nonMouseDown\nonMouseUp\nonMouseLeave\nonTouchStart\nonTouchEnd","examples#Examples":"function TestComponent() {\n  const [isLongPressed, setLongPressed] = useState(false);\n  const attrs = useLongPress(() => {\n    setLongPressed(true);\n  });\n  return (\n    <div>\n      <h1>{isLongPressed ? '✨ LONG PRESS ✨' : 'USE-REACT-HOOKS'}</h1>\n      <button {...attrs}>PRESS</button>\n      <button onClick={() => setLongPressed(false)}>RESET</button>\n    </div>\n  );\n}"}},"/hooks/useMockData":{"title":"useMockData","data":{"introduce#Introduce":"주어진 스키마와 옵션을 바탕으로 모의 데이터를 생성합니다.필요한 형태의 데이터를 쉽게 테스트하고 사용할 수 있도록 구성이 되어있습니다.\ninterface UseMockDataProps<S extends Schema> {\n  options?: Partial<Options>;\n  schema: S;\n}\ninterface UseMockDataReturns<T> {\n  mockData: T;\n  addItem: () => void;\n}\nconst useMockData = <S extends Schema>(\n  props: UseMockDataProps<S>\n): UseMockDataReturns<SchemaToType<S>[]> => { ... }","props#Props":"schema : 모의 데이터의 구조를 정의하는 스키마 객체입니다. 각 필드의 타입과 구조를 설정할 수 있습니다.\noptions : 데이터 생성과 관련된 옵션을 지정할 수 있는 객체입니다. 기본적으로 설정된 defaultOptions이 사용되며, 필요 시 이를 덮어쓸 수 있습니다.\noptions.count : 생성될 요소의 개수를 명시합니다.\noptions.type : 각 데이터 타입에 대한 기본 생성 범위를 설정하는 객체입니다.\nconst defaultOptions: Options = {\n  count: 1, // 생성될 더미데이터 요소의 개수\n  type: {\n    string: {\n      // 문자열 길이 범위\n      min: 3,\n      max: 10,\n    },\n    number: {\n      // 숫자 생성 범위\n      min: 1,\n      max: 100,\n    },\n    image: {\n      // 이미지 너비, 높이 범위\n      width: {\n        min: 800,\n        max: 2560,\n      },\n      height: {\n        min: 600,\n        max: 1440,\n      },\n    },\n    date: {\n      // 날짜 범위\n      start: formatDateToYYYYMMDD(),\n      end: formatDateToYYYYMMDD(1),\n    },\n  },\n};","returns#Returns":"mockData : 주어진 스키마에 따라 생성된 모의 데이터 배열입니다.\naddItem : 새로운 모의 데이터를 추가하는 함수입니다. 호출 시 현재 schema에 기반해 새로운 항목이 배열에 추가됩니다.\n스키마에 정의된 날짜 범위가 유효하지 않을 경우 오류가 발생할 수 있습니다. (예:\n시작 날짜가 종료 날짜보다 나중인 경우)","examples#Examples":"import React from 'react';\nimport useMockData, { useMockDataSchema } from './useMockData';\nconst schema: useMockDataSchema = {\n  user: {\n    id: 'UUID',\n    name: 'string',\n    posts: [\n      {\n        title: 'string',\n        content: 'string',\n        tags: ['string'],\n        comments: [\n          {\n            userId: 'UUID',\n            comment: 'string',\n            createdAt: 'date',\n          },\n        ],\n      },\n    ],\n    profile: {\n      avatar: 'image',\n      bio: 'string',\n      followers: [\n        {\n          followerId: 'UUID',\n          followedAt: 'date',\n        },\n      ],\n    },\n  },\n};\nconst TestComponent: React.FC = () => {\n  const { mockData, addItem } = useMockData({ schema });\n  // mockData 데이터\n  // [\n  //   {\n  //     \"user\": {\n  //       \"id\": \"249ad9db-db18-4a92-b38d-6f17894e36e3\",\n  //       \"name\": \"Rhudl\",\n  //       \"posts\": [\n  //         {\n  //           \"title\": \"Utvdwx\",\n  //           \"content\": \"Hqskuyacjz\",\n  //           \"tags\": [\n  //             \"Ufgca\"\n  //           ],\n  //           \"comments\": [\n  //             {\n  //               \"userId\": \"97a3b3c9-1a96-492c-954b-96c62f731291\",\n  //               \"comment\": \"Iffaf\",\n  //               \"createdAt\": \"2024-11-16T15:23:23.481Z\"\n  //             }\n  //           ]\n  //         }\n  //       ],\n  //       \"profile\": {\n  //         \"avatar\": \"https://picsum.photos/2427/697\",\n  //         \"bio\": \"Wtxaccpqj\",\n  //         \"followers\": [\n  //           {\n  //             \"followerId\": \"a6c324ce-18be-49d3-a4d3-86ecb8bc9756\",\n  //             \"followedAt\": \"2024-10-26T13:14:18.015Z\"\n  //           }\n  //         ]\n  //       }\n  //     }\n  //   }\n  // ]\n  return (\n    <div>\n      <h1>Mock Data with Nested Structures</h1>\n      <pre>{JSON.stringify(mockData, null, 2)}</pre>\n      <button onClick={addItem}>Add Item</button>\n    </div>\n  );\n};\nexport default TestComponent;"}},"/hooks/useMousePosition":{"title":"useMousePosition","data":{"introduce#Introduce":"마우스의 현재 위치를 감지하여 반환합니다.\ninterface UseMousePositionProps {\n  delayTime?: number;\n  animationMode?: boolean;\n}\ninterface UseMousePositionReturns {\n  viewX: number | null;\n  viewY: number | null;\n  pageX: number | null;\n  pageY: number | null;\n  screenX: number | null;\n  screenY: number | null;\n  elementX: number | null;\n  elementY: number | null;\n  refW: number | null;\n  refH: number | null;\n  targetRef: Dispatch<SetStateAction<Element | null>>;\n}\nconst useMousePosition = (props: UseMousePositionProps): UseMousePositionReturns","props#Props":"","이벤트핸들링-빈도-및-애니메이션-옵션-활용#이벤트핸들링 빈도 및 애니메이션 옵션 활용":"delayTime : 이벤트 핸들링을 지연시킬 값 (기본값: 1000/60ms)\nanimationMode : 부드러운 이동 혹은 애니메이션 효과를 위해 애니메이션 모드 활성화 여부 선택","returns#Returns":"","기본#기본":"viewX : 뷰포트에서의 마우스 x 좌표\nviewY : 뷰포트에서의 마우스 y 좌표\npageX : 페이지에서의 마우스 x 좌표\npageY : 페이지에서의 마우스 y 좌표\nscreenX : 화면에서의 마우스 x 좌표\nscreenY : 화면에서의 마우스 y 좌표","element-지정-시#Element 지정 시":"elementX : 지정된 Element left 기준의 마우스 x 좌표\nelementY : 지정된 Element top 기준의 마우스 y 좌표\nrefW : 지정된 Element의 너비\nrefH : 지정된 Element의 높이\ntargetRef : 해당 엘리먼트 기준으로 마우스 좌표를 계산하기 위해 지정하는 참조 객체","examples#Examples":"Element를 지정해서 상대 좌표 및 Element 크기 활용 예시\nconst TestComponent = () => {\n  const { elementX, elementY, refW, refH, targetRef } = useMousePosition({ delayTime: 100 });\n  return (\n    <div\n      ref={targetRef}\n      style={{ width: '300px', height: '200px', border: '1px solid black' }}\n    >\n      <p>Element X: {elementX}</p>\n      <p>Element Y: {elementY}</p>\n      <p>Element Width: {refW}px</p>\n      <p>Element Height: {refH}px</p>\n    </div>\n  );\n};\ndelayTime이 기본값(1000/60ms) 보다 커지면 훅의 성능이 개선될 수 있지만, 반응\n속도는 약간 느려질 수 있습니다.\nanimationMode 활성 시 delayTime 설정이 무시됩니다."}},"/hooks/useOnlineStatus":{"title":"useOnlineStatus","data":{"introduce#Introduce":"온라인/오프라인 네트워크 상태를 판별하는 훅입니다.\ninterface UseOnlineStatusProps {\n  onlineCallback?: () => void;\n  offlineCallback?: () => void;\n}\ninterface UseOnlineStatusReturns {\n  isOnline: boolean;\n}\nconst useOnlineStatus = ( props: UseOnlineStatusProps): UseOnlineStatusReturns\n브라우저의 온라인/오프라인 상태를 추적하는 훅입니다.\n온라인 상태가 변경될 때 실행할 콜백 함수를 선택적으로 지정할 수 있습니다.\n콜백 함수들은 useCallback을 사용해 메모이제이션하여 의도하지 않은 재생성을\n방지하고 성능을 최적화할 것을 권장합니다.","props#Props":"onlineCallback : 브라우저가 온라인 상태가 될 때 실행할 콜백 함수\nofflineCallback : 브라우저가 오프라인 상태가 될 때 실행할 콜백 함수","returns#Returns":"isOnline : 현재 온라인 상태","examples#Examples":"function TestComponent() {\n  const { isOnline } = useOnlineStatus({ onlineCallback, offlineCallback });\n  function onlineCallback() {\n    console.log('online');\n  }\n  function offlineCallback() {\n    console.log('offline');\n  }\n  return (\n    <div>\n      <h1>{isOnline ? 'online' : 'offline'}</h1>\n    </div>\n  );\n}"}},"/hooks/useOutsideClick":{"title":"useOutsideClick","data":{"introduce#Introduce":"지정된 엘리먼트 외부에서 발생하는 클릭 이벤트를 감지하고, 외부 클릭 시 콜백 함수를 호출하는 훅입니다.\n모달, 드롭다운 메뉴 등에서 외부 클릭을 감지하여 닫기 기능을 구현할 때 유용합니다.\nexport interface UseOutsideClickProps {\n  onClickOutside: () => void;\n  events?: EventType[];\n}\ntype EventType = 'mousedown' | 'mouseup' | 'touchstart' | 'touchend';\nconst useOutsideClick = ({\n  onClickOutside,\n  events = ['mousedown', 'touchstart'],\n}: UseOutsideClickProps): RefObject<HTMLElement>","props#Props":"onClickOutside : 엘리먼트 외부에서 전달한 이벤트가 발생했을 때 호출되는 콜백 함수입니다.\nevents : 감지할 이벤트 타입을 지정할 수 있습니다. 기본값은 ['mousedown', 'touchstart']입니다.","returns#Returns":"클릭 이벤트를 감지할 DOM 엘리먼트에 연결할 ref 객체를 반환합니다.","examples#Examples":"function ExampleComponent() {\n  const handleClickOutside = () => {\n    alert('외부 클릭이 감지되었습니다.');\n  };\n  const ref = useOutsideClick({\n    onClickOutside: handleClickOutside,\n  });\n  return (\n    <div>\n      <div ref={ref} style={{ padding: '20px', backgroundColor: '#f0f0f0' }}>\n        이 박스 외부를 클릭하면 알림이 뜹니다.\n      </div>\n    </div>\n  );\n}\nexport default ExampleComponent;"}},"/hooks/usePermission":{"title":"usePermission","data":{"introduce#Introduce":"사용자의 권한 상태의 변화를 감지하고, 권한 요청에 대한 상태를 자동으로 처리하는 훅입니다.\ninterface UsePermissionProps {\n  permission:\n    | 'accessibility-events'\n    | 'accelerometer'\n    | 'ambient-light-sensor'\n    | 'background-fetch'\n    | 'background-sync'\n    | 'bluetooth'\n    | 'camera'\n    | 'captured-surface-control'\n    | 'clipboard-read'\n    | 'clipboard-write'\n    | 'display-capture'\n    | 'fullscreen'\n    | 'geolocation'\n    | 'gyroscope'\n    | 'idle-detection'\n    | 'keyboard-lock'\n    | 'local-fonts'\n    | 'magnetometer'\n    | 'microphone'\n    | 'midi'\n    | 'nfc'\n    | 'notifications'\n    | 'payment-handler'\n    | 'periodic-background-sync'\n    | 'persistent-storage'\n    | 'pointer-lock'\n    | 'push'\n    | 'screen-wake-lock'\n    | 'speaker-selection'\n    | 'storage-access'\n    | 'system-wake-lock'\n    | 'top-level-storage-access'\n    | 'window-management';\n}\ninterface UsePermissionReturns {\n  status: 'granted' | 'prompt' | 'denied' | 'notSupported';\n}\nconst useSomethingHook = (props: UsePermissionProps): UsePermissionReturns\n주어진 권한에 대한 상태를 확인하고, 권한 상태가 변경될 때마다 업데이트합니다.","props#Props":"permission : 확인하려는 권한의 이름을 입력합니다. Permission 타입은 사전 정의된 권한 이름과 문자열 모두 허용됩니다.\n사전 정의된 권한은 Firefox, Chromium, WebKit에서 공통으로 사용하는 권한입니다.","returns#Returns":"status : 현재 권한의 상태를 반환합니다.\n상태 값은 다음 중 하나일 수 있습니다: granted | prompt | denied |\nnotSupported\n클라이언트 환경이 아니거나 Permissions API가 지원되지 않는 경우, 권한 상태가\n'notSupported'로 설정됩니다.","examples#Examples":"import React from 'react';\nimport usePermission from './usePermission';\nconst TestComponent = () => {\n  const { status } = usePermission({ permission: 'geolocation' }); // prompt\n  return (\n    <div>\n      <h1>권한 상태: {status}</h1>\n    </div>\n  );\n};\nexport default TestComponent;"}},"/hooks/usePrefersColorScheme":{"title":"usePrefersColorScheme","data":{"":"대부분의 최신 브라우저는 prefers-color-scheme 미디어 쿼리를 지원합니다. 하지만, 일부 구형 브라우저에서는 지원되지 않을 수 있으므로 주의가 필요합니다.","introduce#Introduce":"usePrefersColorScheme 훅은 사용자의 시스템에서 선호하는 색상 모드(다크 모드 또는 라이트 모드)를 감지하고 반환하는 기능을 제공합니다.\nexport interface UsePrefersColorSchemeProps {\n  serverSnapshot?: UsePrefersColorSchemeReturns;\n}\nexport type UsePrefersColorSchemeReturns = 'dark' | 'light';\nconst usePrefersColorScheme = (props: UsePrefersColorSchemeProps = {}): UsePrefersColorSchemeReturns;","props#Props":"serverSnapshot : 서버 사이드 렌더링(SSR) 시 초기 색상 모드를 설정하기 위한 선택적 값입니다. 기본값은 'light'입니다.","returns#Returns":"UsePrefersColorSchemeReturns : 선호 색상 모드 값을 반환합니다. 두 가지 옵션이 있습니다.\ndark : 다크 모드\nlight : 라이트 모드","examples#Examples":"import usePrefersColorScheme from './usePrefersColorScheme';\n  const App = () => {\n    const colorScheme = usePrefersColorScheme();\n    return (\n      <div>\n        <h1>현재 색상 모드: {colorScheme === 'dark' ? '다크 모드' : '라이트 모드'}</h1>\n        {colorScheme === 'dark' ? (\n          <p>사용자 시스템은 현재 다크 모드입니다.</p>\n        ) : (\n          <p>사용자 시스템은 현재 라이트 모드입니다.</p>\n        )}\n      </div>\n    );\n  };\n  export default App;"}},"/hooks/usePreventCopy":{"title":"usePreventCopy","data":{"introduce#Introduce":"브라우저에서 복사 이벤트를 차단하는 훅입니다.\nconst usePreventCopy = (callback?: () => void): void\n복사(또는 잘라내기) 이벤트를 차단하고 콜백 함수를 실행합니다.\n콜백 함수를 인자로 넘기지 않으면 단순히 복사 이벤트만 차단합니다.","props#Props":"callback: 복사 이벤트가 발생할 때 실행할 콜백 함수","examples#Examples":"import { usePreventCopy } from '@frontend-opensource/use-react-hooks';\nconst TestComponent = () => {\n  const callbackCopy = () => {\n    alert('복사할 수 없습니다.');\n  };\n  usePreventCopy(callbackCopy);\n  return (\n    <div>\n      <h1>USE-REACT-HOOKS</h1>\n    </div>\n  );\n};"}},"/hooks/useScrollLock":{"title":"useScrollLock","data":{"introduce#Introduce":"페이지의 스크롤을 잠궈 사용자가 스크롤할 수 없도록 합니다.(스크롤 바가 비활성화된 상태로, UI형태가 유지된 형태)\nconst useScrollLock = (props: boolean): void","props#Props":"boolean 값으로 스크롤의 잠금 여부를 관리합니다.","examples#Examples":"const TestComponent = () => {\n  const [isModalOpen, setIsModalOpen] = useState<boolean>(false);\n  useScrollLock(isModalOpen);\n  const openModal = () => {\n    setIsModalOpen(true);\n  };\n  const closeModal = () => {\n    setIsModalOpen(false);\n  };\n  return (\n    <div style={styles.container}>\n      {isModalOpen && (\n        <div style={styles.modal}>\n          <div style={styles.modalContent}>\n     ...\n    </div>\n  );\n};"}},"/hooks/useScrollY":{"title":"useScrollY","data":{"introduce#Introduce":"현재 페이지의 스크롤 위치를 저장하고 이동하는 함수를 반환하는 훅입니다.\ninterface UseScrollYReturns {\n  moveTrigger: () => void;\n}\nconst useScrollY = (): UseScrollYReturns","returns#Returns":"moveTrigger: 저장된 스크롤 위치로 이동하는 함수","examples#Examples":"import { useScrollY } from '@frontend-opensource/use-react-hooks';\nfunction TestComponent() {\n  const { moveTrigger } = useScrollY();\n  useEffect(() => {\n    moveTrigger();\n  }, []);\n  return (\n    <div>\n      <h1>USE-REACT-HOOKS</h1>\n    </div>\n  );\n}"}},"/hooks/useSound":{"title":"useSound","data":{"introduce#Introduce":"useSound 훅은 오디오를 재생하고, 재생 상태를 제어하며, 오디오의 여러 속성을 설정할 수 있는 기능을 제공합니다.\n이 훅을 사용하여 오디오를 로드하고 재생하는 동안 다양한 이벤트(재생, 일시정지, 종료 등)에 대한 콜백을 설정할 수 있습니다.\nexport interface UseSoundProps {\n  url: string;\n  onLoad?: Fn;\n  onPlay?: Fn;\n  onPause?: Fn;\n  onEnd?: Fn;\n  loop?: boolean;\n  defaultVolume?: number;\n  defaultPlaybackRate?: number;\n}\nexport interface UseSoundReturns {\n  error: ErrorEvent | null;\n  volume: number;\n  playbackRate: number;\n  isLoop: boolean;\n  isMuted: boolean;\n  isLoading: boolean;\n  isPlaying: boolean;\n  isPaused: boolean;\n  duration: number;\n  currentTime: number;\n  play: Fn;\n  pause: Fn;\n  stop: Fn;\n  setMute: Fn;\n  setUnmute: Fn;\n  setIsLoop: (loop: boolean) => void;\n  setPosition: (time: number) => void;\n  setVolume: (volume: number) => void;\n  setPlaybackRate: (rate: number) => void;\n}\nconst useSound = (props: UseSoundProps): UseSoundReturns","props#Props":"url : 오디오 파일의 URL (필수)\nloop : 반복 재생 여부 (기본값: false)\ndefaultVolume : 초기 볼륨 값 (범위: 0.0 ~ 1.0, 기본값: 1)\ndefaultPlaybackRate : 초기 재생 속도 값 (범위: 0.5 ~ 4.0, 기본값: 1)\nonLoad : 오디오가 성공적으로 로드되었을 때 호출되는 콜백 함수\nonPlay : 오디오 재생이 시작되었을 때 호출되는 콜백 함수\nonPause : 오디오가 일시 정지 되었을 때 호출되는 콜백 함수\nonEnd : 오디오 재생이 끝났을 때 호출되는 콜백 함수","returns#Returns":"","오디오-상태#오디오 상태":"error : 오디오 로드 중 발생한 오류 (ErrorEvent 또는 null)\nvolume : 현재 볼륨 값 (0.0 ~ 1.0)\nplaybackRate : 현재 재생 속도 값 (0.5 ~ 4.0)\nisLoop : 반복 재생 여부\nisMuted : 음소거 여부\nisLoading : 오디오가 로드 중인지 여부\nisPlaying : 오디오가 재생 중인지 여부\nisPaused : 오디오가 일시 정지되었는지 여부\nduration : 오디오의 전체 길이 (초 단위)\ncurrentTime : 오디오의 현재 재생 위치 (초 단위)","오디오-제어-함수#오디오 제어 함수":"play : 오디오를 재생하는 함수\npause : 오디오를 일시 정지하는 함수\nstop : 오디오를 정지하는 함수 (재생 위치가 0으로 돌아갑니다)\nsetMute : 오디오를 음소거하는 함수\nsetUnmute : 오디오 음소거를 해제하는 함수\nsetIsLoop : 반복 재생 여부를 설정하는 함수 (loop: boolean)\nsetPosition : 오디오 재생 위치를 설정하는 함수 (time: number)\nsetVolume : 볼륨 값을 설정하는 함수 (volume: number)\nsetPlaybackRate : 재생 속도를 설정하는 함수 (rate: number)","examples#Examples":"const App = () => {\n  const result = useSound({\n    url: 'https://github.com/rafaelreis-hotmart/Audio-Sample-files/raw/master/sample.mp3',\n  });\n  const {\n    volume,\n    playbackRate,\n    isLoop,\n    duration,\n    currentTime,\n    play,\n    pause,\n    stop,\n    setIsLoop,\n    setPosition,\n    setVolume,\n    setPlaybackRate,\n  } = result;\n  const handleVolumeChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setVolume(parseFloat(e.target.value));\n  };\n  const handlePlaybackRateChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setPlaybackRate(parseFloat(e.target.value));\n  };\n  const handlePositionChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setPosition(parseFloat(e.target.value));\n  };\n  return (\n    <div>\n      <button onClick={play}>재생</button>\n      <button onClick={pause}>일시정지</button>\n      <button onClick={stop}>정지</button>\n      <div>\n        <label>\n          볼륨:\n          <input\n            type=\"range\"\n            min=\"0\"\n            max=\"1\"\n            step=\"0.01\"\n            value={volume}\n            onChange={handleVolumeChange}\n          />\n        </label>\n      </div>\n      <div>\n        <label>\n          배속:\n          <input\n            type=\"range\"\n            min=\"0.5\"\n            max=\"2\"\n            step=\"0.1\"\n            value={playbackRate}\n            onChange={handlePlaybackRateChange}\n          />\n        </label>\n      </div>\n      <div>\n        <label>\n          재생 위치:\n          <input\n            type=\"range\"\n            min=\"0\"\n            max={duration}\n            step=\"0.1\"\n            value={currentTime}\n            onChange={handlePositionChange}\n          />\n        </label>\n      </div>\n      <div>\n        <label>\n          반복 재생:\n          <input\n            type=\"checkbox\"\n            checked={isLoop}\n            onChange={(e) => setIsLoop(e.target.checked)}\n          />\n        </label>\n      </div>\n    </div>\n  );\n};\nexport default App;\n브라우저마다 지원하는 오디오 포맷이 다를 수 있습니다. 대부분의 브라우저는 MP3, WAV, OGG 등을 지원하며, 파일을 로드하기 전에 호환성을 확인하는 것이 좋습니다."}},"/hooks/useTimer":{"title":"useTimer","data":{"introduce#Introduce":"지정된 시간이 지난 후 콜백 함수를 실행하는 타이머 훅입니다. 타이머를 시작하거나 취소할 수 있습니다.\ninterface UseTimerReturns {\n  start: () => void;\n  cancel: () => void;\n}\nconst useTimer = (callback: () => void, ms: number): UseTimerReturns","props#Props":"callback : 타이머가 완료된 후 실행할 함수\nms : 타이머가 작동할 지연 시간 (밀리초)","returns#Returns":"start : 타이머를 시작하는 함수\ncancel : 현재 활성화된 타이머를 취소하는 함수","examples#Examples":"import React, { useState } from 'react';\nimport useTimer from './useTimer';\nconst TestComponent = () => {\n  const [count, setCount] = useState(0);\n  const { start, cancel } = useTimer(() => setCount((prev) => prev + 1), 2000);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={start}>Start Timer</button>\n      <button onClick={cancel}>Cancel Timer</button>\n    </div>\n  );\n};\n타이머가 시작되면 지정된 시간(ms)이 지난 후에 콜백 함수가 실행됩니다.\n타이머가 활성화된 상태에서 다시 시작(start)하면 기존 타이머는 취소되고\n새로운 타이머가 시작됩니다."}},"/hooks/useToggle":{"title":"useToggle","data":{"introduce#Introduce":"boolean 값을 토글하는 훅입니다.\nconst useToggle = ( initialValue: boolean): [boolean, (nextValue?: unknown) => void]\n상태를 토글하거나, 전달된 값으로 상태를 설정할 수 있습니다.\n상태 변경 함수는 인자로 boolean 값을 받을 수 있으며, 전달된 값이 boolean이 아니면 현재 상태의 반대값으로 설정됩니다.\n모달을 표시하고 숨기거나, 사이드 메뉴를 열거나 닫을 때처럼 어떤 동작을 반대 동작으로 바꾸고 싶을 때 유용합니다.","props#Props":"initialValue : 토글의 시작 상태 설정 (true/false)","returns#Returns":"state : 현재 상태값\ntoggle : 상태를 토글하거나 지정된 값을 설정","examples#Examples":"const TestComponent = () => {\n  const [state, toggle] = useToggle(true);\n  return (\n    <div>\n      <div>{state ? 'ON' : 'OFF'}</div>\n      <button onClick={toggle}>Toggle</button>\n      <button onClick={() => toggle(true)}>set ON</button>\n      <button onClick={() => toggle(false)}>set OFF</button>\n      <button onClick={() => toggle('something')}>\n        set something (Also toggle)\n      </button>\n    </div>\n  );\n};"}},"/hooks/useTranslation":{"title":"useTranslation","data":{"introduce#Introduce":"텍스트를 사용자가 지정한 언어로 변경합니다.\ninterface UseTranslationReturns {\n  t: (key: string, variables?: { [key: string]: string | number }) => string;\n  language: string;\n  changeLanguage: (lang: string) => void;\n}\nconst useTranslation = (): UseTranslationReturns\nchangeLanguage() 함수를 사용해 언어를 지정할 수 있습니다.\nt() 함수를 사용해 지정한 언어에 해당하는 번역된 텍스트를 가져올 수 있습니다.","examples#Examples":"useTranslation()을 사용하기 전에 먼저 TranslationProvider를 선언해야\n합니다.\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\nimport { TranslationProvider } from './context/TranslationContext';\nconst translations = {\n  en: {\n    greeting: 'Hello ${name}, You have ${count} new messages.',\n    farewell: 'Goodbye ${name}',\n  },\n  ko: {\n    greeting: '안녕하세요 ${name}, 새 메시지가 ${count}개 있습니다.',\n    farewell: '안녕히 가세요 ${name}',\n  },\n};\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <TranslationProvider translations={translations} defaultLanguage=\"en\">\n    <App />\n  </TranslationProvider>\n);\nimport { useTranslation } from './hooks/useTranslation';\nconst App = () => {\n  const { t, language, changeLanguage } = useTranslation();\n  const handleLanguageChange = (lang: string) => {\n    changeLanguage(lang);\n  };\n  return (\n    <div>\n      <h1>{t('greeting', { name: 'Choo', count: 5 })}</h1>\n      <p>{t('farewell', { name: 'Choo' })}</p>\n      <div>\n        <button onClick={() => handleLanguageChange('en')}>English</button>\n        <button onClick={() => handleLanguageChange('ko')}>한국어</button>\n      </div>\n      <p>Current Language: {language}</p>\n    </div>\n  );\n};\nexport default App;"}},"/hooks/useUnmountEffect":{"title":"useUnmountEffect","data":{"introduce#Introduce":"useUnmountEffect는 컴포넌트가 언마운트될 때 지정한 콜백 함수를 실행하는 훅입니다.\n컴포넌트가 언마운트 되는 시점에 클린업 작업을 수행하고자 할 때 유용합니다.\ninterface UseUnmountEffectReturns {\n  setUnmountCallback: (callback: () => void) => void;\n}\nconst useUnmountEffect = ():UseUnmountEffectReturns","returns#Returns":"callback: 컴포넌트가 언마운트될 때 실행할 콜백 함수","examples#Examples":"function TestComponent() {\n  const { setUnmountCallback } = useUnmountEffect();\n  setUnmountCallback(() => {\n    console.log('TestComponent가 언마운트되었습니다.');\n  });\n  return (\n    <>\n      <DummyComponents />\n      <SomeComponents />\n    </>\n  );\n}\nexport default ExampleComponent;"}},"/hooks/useWindowSize":{"title":"useWindowSize","data":{"introduce#Introduce":"브라우저의 너비와 높이를 반환하는 훅입니다. 브라우저 창의 크기가 변경될 때마다 업데이트된 값을 반환합니다.\ninterface UseWindowSizeReturns {\n  width: number | null;\n  height: number | null;\n}\nconst useWindowSize = <T extends number>(\n  delayTime: PositiveInteger<T>\n): UseWindowSizeReturns","props#Props":"delayTime: 과도한 이벤트 실행을 방지하기 위해 resize 이벤트를 지연시키는 시간(ms)\ndefault: 200","returns#Returns":"width: 브라우저의 너비\nheight: 브라우저의 높이","examples#Examples":"import { useWindowSize } from '@frontend-opensource/use-react-hooks';\nfunction TestComponent() {\n  const { width, height } = useWindowSize();\n  return (\n    <div>\n      <p>width: {width}px</p>\n      <p>height: {height}px</p>\n    </div>\n  );\n}"}},"/hooks/useWorker":{"title":"useWorker","data":{"introduce#Introduce":"웹 워커를 사용하여 비동기 작업을 처리하는 훅입니다.비동기 작업을 백그라운드에서 실행하여 UI 스레드의 성능을 향상시킵니다.\ninterface UseWorkerProps<Arg, Return, Closure = never> {\n  script: WorkerScript<Arg, Return, Closure>;\n}\ninterface UseWorkerReturns<Return> {\n  result: Return | undefined;\n  start: (args: Arg, closure?: Closure) => void;\n  cancel: () => void;\n}\nconst useWorker = <Arg, Return, Closure = never>(props: UseWorkerProps<Arg, Return, Closure>): UseWorkerReturns<Return>\n메인 스레드(주 스레드)와는 별도의 스레드에서 자바스크립트 코드를 실행하여 작업을 수행하고,\n메인 스레드가 UI 렌더링과 같은 다른 작업을 차질 없이 진행할 수 있도록 도와줍니다.\n기본적인 작업 외에 네트워크 요청도 워커 스레드 내부에서 동작이 가능하도록 구현하였습니다.\n컴포넌트가 언마운트될 때, 사용 중이던 웹 워커를 자동으로 정리합니다.","props#Props":"script - 웹 워커에서 실행할 함수를 전달합니다.","returns#Returns":"result : 작업의 결과를 저장하는 상태 값입니다. 작업이 완료되면 값이 동적으로 업데이트됩니다.\nstart : 작업을 시작하는 함수입니다. 이 함수를 호출하면 웹 워커가 생성되고 작업이 시작됩니다.\ncancel : 현재 진행 중인 작업을 취소하는 함수입니다. 호출 시 활성화된 웹 워커가 종료됩니다.\nuseWorker 훅은 브라우저 환경에서만 동작합니다.","type#Type":"Arg : 작업에 필요한 인수 타입입니다.\nReturn : 작업 결과의 반환 타입입니다.\nClosure :클로저(closure)로 전달될 타입입니다. 전달된 값은 작업 스레드의 추가 인자로 전달됩니다. (선택 사항)","examples#Examples":"const App = () => {\n  const [count, setCount] = useState(0);\n  // <SynchronousComponent /> 컴포넌트는 매우 복잡한 계산이 수행될 때,\n  // 버튼 클릭과 같은 상호작용 이벤트가 처리되지 않는 블로킹 현상이 발생합니다.\n  // 반면, <WorkerComponent /> 컴포넌트는 웹 워커를 사용해 무거운 작업을 별도의 스레드에서 처리하므로,\n  // 메인 스레드에서는 버튼 클릭과 같은 이벤트를 원활하게 처리할 수 있습니다.\n  return (\n    <div>\n      <h1>O(n^2) 100억 연산 블로킹 테스트</h1>\n      <h1>메인 스레드 비블로킹 작업 (Web Worker 사용)</h1>\n      <WorkerComponent />\n      <h1>메인 스레드 블로킹 작업 (Web Worker 미사용)</h1>\n      <SynchronousComponent />\n      <button\n        onClick={() =>\n          setCount((prev) => prev + 1)\n        }>{`나를 클릭해주세요!: ${count}`}</button>\n    </div>\n  );\n};\nconst size = 100_000;\n// 테스트용 O(n^2) 작업\nconst workerScript = (num: number): number => {\n  let sum = 0;\n  for (let i = 1; i <= num; i++) {\n    for (let j = 1; j <= num; j++) {\n      sum += i * j;\n    }\n  }\n  return sum;\n};\nconst WorkerComponent = () => {\n  const [input, setInput] = useState(size);\n  const { result, start, cancel } = useWorker(workerScript);\n  const handleStart = () => {\n    start(input);\n  };\n  return (\n    <div>\n      <input\n        type=\"number\"\n        value={input}\n        disabled\n        onChange={(e) => setInput(parseInt(e.target.value, 10))}\n      />\n      <button onClick={handleStart}>Start Worker</button>\n      <button onClick={cancel}>Cancel Worker</button>\n      <pre>{result ? JSON.stringify(result, null, 2) : 'No result'}</pre>\n    </div>\n  );\n};\nconst SynchronousComponent = () => {\n  const [input, setInput] = useState(size);\n  const [result, setResult] = useState(0);\n  const handleStart = () => {\n    setResult(workerScript(input));\n  };\n  return (\n    <div>\n      <input\n        type=\"number\"\n        value={input}\n        disabled\n        onChange={(e) => setInput(parseInt(e.target.value, 10))}\n      />\n      <button onClick={handleStart}>Start Synchronous</button>\n      <div>Result: {result}</div>\n    </div>\n  );\n};"}},"/":{"title":"useReactHooks","data":{"":"useReactHooks는 리액트 개발 시 반복적인 커스텀 훅 제작의 비효율을 개선하여, 효율적이고 재사용 가능한 훅을 제공합니다. \n누구나 쉽게 접근할 수 있는 오픈소스 프로젝트로, 커뮤니티의 기여와 확장을 통해 함께 성장해 나가고자 합니다.\n  npm install @frontend-opensource/use-react-hooks","특징#특징":"유용한 커스텀 훅 제공: 실무에서 자주 사용되는 다양한 커스텀 훅들이 포함되어 있어, 개발자는 복잡한 기능을 손쉽게 구현할 수 있습니다.\n오픈소스 기여 가능: 많은 개발자가 라이브러리를 포크하고 커스터마이징할 수 있도록 오픈소스로 배포되어 있으며, 자유롭게 기여할 수 있습니다.\nnpm 패키지 배포: 누구나 쉽게 설치하고 사용할 수 있도록 npm 패키지로 배포되어 있습니다."}}}